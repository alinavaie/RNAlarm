import {Platform} from 'react-native';
import PushNotification from 'react-native-push-notification';

class NotificationHandler {
  // (required) Called when a remote is received or opened, or local notification is opened
  onNotification(notification) {
    console.log('NotificationHandler:', notification);

    if (typeof this._onNotification === 'function') {
      this._onNotification(notification);
    }
  }

  // (optional) Called when Token is generated (iOS and Android)
  onRegister(token) {
    console.log('NotificationHandler:', token);

    if (typeof this._onRegister === 'function') {
      this._onRegister(token);
    }
  }

  createNewNotification(copyNotification, newxDate) {
    PushNotification.localNotificationSchedule({
      date: new Date(copyNotification.time + newxDate),
      channelId: copyNotification.channelId,
      largeIcon: 'ic_launcher', // (optional) default: "ic_launcher"
      smallIcon: 'ic_notification', // (optional) default: "ic_notification" with fallback for "ic_launcher"
      vibrate: true, // (optional) default: true
      vibration: 1000, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      actions: JSON.parse(copyNotification.actions), // (Android only) See the doc for notification actions to know more
      invokeApp: false, // (optional) This enable click on actions to bring back the application to foreground or stay in background, default: true
      priority: 'high',
      visibility: 'private',
      importance: 'high',
      allowWhileIdle: false,
      ignoreInForeground: false,
      id: copyNotification.notificationId, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      title: copyNotification.title, // (optional)
      message: '', // (required)
      userInfo: copyNotification.userInfo, // (optional) default: {} (using null throws a JSON value '<null>' error)
      playSound: true, // (optional) default: true
      repeatType: copyNotification.repeatType,
      repeatTime: 1,
    });
  }

  createSnoozeNotification(copyNotification, newxDate) {
    PushNotification.localNotificationSchedule({
      date: new Date(
        copyNotification.time +
          newxDate +
          1000 * 60 * copyNotification.userInfo.snoozeTime,
      ),
      channelId: copyNotification.channelId,
      largeIcon: 'ic_launcher', // (optional) default: "ic_launcher"
      smallIcon: 'ic_notification', // (optional) default: "ic_notification" with fallback for "ic_launcher"
      vibrate: true, // (optional) default: true
      vibration: 1000, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      actions: JSON.parse(copyNotification.actions), // (Android only) See the doc for notification actions to know more
      invokeApp: false, // (optional) This enable click on actions to bring back the application to foreground or stay in background, default: true
      priority: 'high',
      visibility: 'private',
      importance: 'high',
      allowWhileIdle: false,
      ignoreInForeground: false,
      id: copyNotification.userInfo.snoozId, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      title: copyNotification.title, // (optional)
      message: '', // (required)
      userInfo: copyNotification.userInfo, // (optional) default: {} (using null throws a JSON value '<null>' error)
      playSound: true, // (optional) default: true
      repeatType: 'minute',
      repeatTime: copyNotification.userInfo.snoozeTime,
    });
  }

  // (optional) Called when Registered Action is pressed and invokeApp is false, if true onNotification will be called (Android)
  onAction(notification) {
    console.log('Notification action received:');
    console.log(notification.action);
    console.log(notification);

    const copyNotification = notification;
    copyNotification.userInfo = JSON.parse(notification.userInfo);
    copyNotification.time = notification.fireDate;
    console.log(copyNotification);
    const newxDate =
      copyNotification.repeatType === 'day'
        ? 60 * 1000 * 60 * 24
        : 60 * 1000 * 60 * 24 * 7;
    if (notification.action === 'Stop Alarm') {
      PushNotification.cancelLocalNotification(notification.id);
      PushNotification.cancelLocalNotification(
        copyNotification.userInfo.snoozId,
      );

      if (copyNotification.repeatType) {
        this.createNewNotification(copyNotification, newxDate);
        this.createSnoozeNotification(copyNotification, newxDate);
      }
    } else if (notification.action === 'Snooze') {
      PushNotification.cancelLocalNotification(notification.id);

      if (copyNotification.repeatType) {
        this.createNewNotification(copyNotification, newxDate);
      }
    } else {
      PushNotification.cancelLocalNotification(
        copyNotification.userInfo.snoozId,
      );
      if (copyNotification.userInfo.repeatMainNotif) {
        this.createSnoozeNotification(copyNotification, newxDate);
      }
    }
  }

  // (optional) Called when the user fails to register for remote notifications. Typically occurs when APNS is having issues, or the device is a simulator. (iOS)
  onRegistrationError(err) {
    console.log(err);
  }

  attachRegister(handler) {
    this._onRegister = handler;
  }

  attachNotification(handler) {
    this._onNotification = handler;
  }
}

const handler = new NotificationHandler();

PushNotification.configure({
  // (optional) Called when Token is generated (iOS and Android)
  onRegister: handler.onRegister.bind(handler),

  // (required) Called when a remote or local notification is opened or received
  onNotification: handler.onNotification.bind(handler),

  // (optional) Called when Action is pressed (Android)
  onAction: handler.onAction.bind(handler),

  // (optional) Called when the user fails to register for remote notifications. Typically occurs when APNS is having issues, or the device is a simulator. (iOS)
  onRegistrationError: handler.onRegistrationError.bind(handler),

  // IOS ONLY (optional): default: all - Permissions to register.
  permissions: {
    alert: true,
    badge: true,
    sound: true,
  },

  // Should the initial notification be popped automatically
  // default: true
  popInitialNotification: true,

  /**
   * (optional) default: true
   * - Specified if permissions (ios) and token (android and ios) will requested or not,
   * - if not, you must call PushNotificationsHandler.requestPermissions() later
   */
  requestPermissions: Platform.OS === 'ios',
});

export default handler;
